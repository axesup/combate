# This is a WIP

Wondering how we do things with Vue instead of with Backbone? Here's the cheat sheet for you!

## Me (and other global objects)

Instead of a global `me` object, use the [Vuex](https://vuex.vuejs.org/en/intro.html) `me` [module](https://vuex.vuejs.org/en/modules.html), with its logged-in-user specific [getters](https://vuex.vuejs.org/en/getters.html) and [actions](https://vuex.vuejs.org/en/actions.html).

```coffeescript
me.get('name')          -> store.state.me.name
me.isAdmin()            -> store.getters['me/isAdmin']
me.sendRecoveryEmail()  -> store.dispatch('me/sendRecoveryEmail')
```

Note that in the context of components, you'll have [helpers](https://vuex.vuejs.org/en/api.html#component-binding-helpers) like `mapState`, `mapGetters`, etc, so each call doesn't have to be so long.

```coffeescript
MyComponent = {
  state: Vuex.mapState('me', ['name']),
  template:' {{ name }}' # renders to what is currently me.name in the "me" store module
}
```

**In-between times**: Changes to `me` User automatically get pushed to `me` store module. New pages, even backbone pages, should use the store instead. Actions on the user module should update the `me` global object until it's fully deprecated, to keep them in sync.

Other globals, such as `features` and `serverConfig` will also move to the global vuex store, either at the root level or as their own modules, as needed.

## Page Layout

Instead of extending `base.jade` and `base-flat.jade`, include the `page-layout` component and put content inside it.

Before:

```jade
extends /templates/base-flat

block content
  div Content...
```

Do this:

```coffeescript
FlatLayout = require 'core/components/FlatLayout'
MyComponent = Vue.extend
  template: require('templates/my-component')()
  components:
    'flat-layout': FlatLayout
```

```jade
flat-layout
  div Content...
```

This is using [Vue.js slots](https://vuejs.org/v2/guide/components.html#Content-Distribution-with-Slots). Currently, it doesn't include footer and header pieces (handled by `RootVue` described later), but eventually FlatLayout will handle the entire page.

## RootView -> RootVue

In order to keep using the Backbone router as-is, use a RootVue as a wrapper for your component. Give it a single root Vue component and, if needed, a vuex store module which will be dynamically added upon navigating to the page.

Before:

```coffeescript
RootView = require 'views/core/RootView'
module.exports = class HomeView extends RootView
  ...
```

Now:

```coffeescript
RootVue = require 'views/core/RootVue'
FlatLayout = require 'core/components/FlatLayout'

MyComponent = Vue.extend
  template: require('templates/some-page')

module.exports = RootVue
  VueComponent: MyComponent
  vuexModule: -> {
    namespaced: true # module will be namespaced to 'page/'
    state: { ... }
  }
```

As shown above, you can include your own module definition, which RootVue will add dynamically as the 'page' module. RootVue will remove that module and all its data when the Router navigates away.

Presumably we'll eventually want to move entirely away from the Backbone Router and use the [vue-router](http://router.vuejs.org/en/essentials/getting-started.html) or something like it instead. The (long) path to do this includes:

* Set up the Backbone Router to handle Vue components without an intermediary wrapper Backbone View
* Migrate all pages to Vue components
* Switch routers in one commit

## Internal components

Say you want to take a smaller piece of a Backbone view and make it a Vue component. To do this, create the vue component instance in the Backbone view's `afterRender` method.

```coffeescript
module.exports = class MyView extends CocoView
  afterRender: ->
    @myComponent = new MyComponent({
      el: @$el.find('#small-corner')[0]
      store
    })
    super(arguments...)
```

Data which needs to be shared between Backbone and vue can be:

* put in a vuex store and have the Backbone view grab it directly through the store object (`require('core/store')`)
* set by the Backbone view to the component's [$data](https://vuejs.org/v2/api/#vm-data)
* listen to the vue component with [$watch](https://vuejs.org/v2/api/#vm-watch)

## Network Requests

Instead of using `$.ajax` or Backbone model/collection methods, call `api` functions which are wrapped around the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).

```coffeescript
# Before
Users = require('collections/Users')
users = new Users()
jqxhr = users.fetch({data: {project:'name'}})
jqxhr.done (rawResponse) -> ...

# Now
api = require('core/api')
promise = api.users.fetch({data: {project:'name'}})
promise.then (rawResponse) -> ...
```

Network errors generated by the API are rejected as objects in the promise. These objects all at least have `message` and `code` properties.

## Page Errors

One of the things the SuperModel does is handle page load errors, re-rendering the page with a generic load error if a necessary resource fails to load. So if you try to go to a classroom page where you don't have access to the page, it'll show a "Forbidden" error. The PageLayout component can do this as well.

```coffeescript
# Before
users = new Users()
@supermodel.trackRequest(users.fetch())

# Now
api.users.fetch({data: {project:'name'}})
.then (users) ->
  ...
.catch (e) ->
  @$store.commit('addPageError', e)
```

This appends the error to a list of errors in the global store, and the PageLayout is set to show the PageErrors component if there are errors, otherwise the given page content. But you can handle these errors however you like for any given page, either by using a different layout component, or doing something else within the `catch`. If network errors are not caught, they show up the same way as they do now: as noty's when in development or logged in as an admin.

## Page Load Progress
There is no generic system for tracking page-load progress to replace the SuperModel. It can easily be replicated, though:

```coffeescript
MyComponent = Vue.extend
  data: -> {
    progress: 0 # have a bootstrap progress bar width keyed off this
  }
  created: ->
    p1 = api.thing.fetch().then(=> this.progress += 0.5)
    p2 = api.otherThing.fetch().then(=> this.progress += 0.5)
    Promise.all([p1,p2]).then ([res1, res2]) ->
      ...
```

Something like this could be generalized with a [Vue mixin](https://vuejs.org/v2/guide/mixins.html).

## Bootstrap

Bootstrap components can generally be used the same as they are now. For example, a [modal with a trigger button](http://getbootstrap.com/javascript/#live-demo) will still work if put into Vue. But it's preferable to store all vue component state in the vue component. So with tabs, instead of using [JavaScript to trigger switching between them](http://getbootstrap.com/javascript/#tabs), key the tab [active class](http://getbootstrap.com/components/#nav-tabs) off the component state and set up logic to change the state when a tab is clicked.

```jade
ul.nav.nav-tabs
  li(v-bind:class="{active: tab === 'home' }" click="setTab('home')") Home
  li(v-bind:class="{active: tab === 'profile' }" click="setTab('profile')") Profile
  li(v-bind:class="{active: tab === 'messages' }" click="setTab('messages')") Messages
```

## Handy Tools

Install the [Vue.js Devtools Chrome Extension](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en). Use it to see what components are on the page and the state of the vuex store.

## File Structure

Where to find/put all these new files?

```
/app
  /core
    /api
      fetch-json.coffee: improved Fetch API function
      index.coffee: puts all the other modules in this folder together, makes it possible to require('/core/api')
      <collection>.coffee: all network endpoints for this collection

    /core
      /components: all non-root-level, common components

    /store
      /modules
        me.coffee: Replacement to global "me"
      index.coffee: Where all the global store pieces and modules are put together. Might get broken down later.

    /templates: where all component templates go

    /views: where all root-level components go
      /core
        RootVue.coffee: shims page-level components to the Router
```