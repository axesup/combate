Wondering how to do something with Vue instead of with Backbone? Here's the cheat sheet for you!

## Me (and other global objects)

Instead of a global `me` object, use the [Vuex](https://vuex.vuejs.org/en/intro.html) `me` [module](https://vuex.vuejs.org/en/modules.html), with its logged-in-user specific [getters](https://vuex.vuejs.org/en/getters.html) and [actions](https://vuex.vuejs.org/en/actions.html).

```coffeescript
me.get('name')          ->  store.state.me.name
me.isAdmin()            ->  store.getters['me/isAdmin']
me.sendRecoveryEmail()  ->  store.dispatch('me/sendRecoveryEmail')
```

Note that in the context of components, you'll have [helpers](https://vuex.vuejs.org/en/api.html#component-binding-helpers) like `mapState`, `mapGetters`, etc, so each call doesn't have to be so long.

```coffeescript
MyComponent = {
  state: Vuex.mapState('me', ['name']),
  template:' {{ name }}' # renders to what is currently me.name in the "me" store module
}
```

While both systems are in use, changes to `me` User automatically get pushed to `me` store module. New or changed logic, even in backbone views, can use the store to speed migration. Actions and mutations on the user module should update the `me` global object until it's fully deprecated, to keep them in sync.

Other globals, such as `features` and `serverConfig` can also be added to the global vuex store, either at the root level or as their own modules, as needed.

## Page Layout

Instead of extending `base.jade` and `base-flat.jade`, include the `page-layout` component and put content inside it.

With Backbone:

```coffeescript
# View
RootView = require 'views/core/RootView'
class MyView extends RootView
  template: require('templates/my-view')
```

```jade
// Template
extends /templates/base-flat

block content
  div Content...
```

With Vue:

```coffeescript
# Component
FlatLayout = require 'core/components/FlatLayout'
MyComponent = Vue.extend
  template: require('templates/my-component')()
  components:
    'flat-layout': FlatLayout
```

```jade
// Template
flat-layout
  div Content...
```

This setup uses [Vue.js slots](https://vuejs.org/v2/guide/components.html#Content-Distribution-with-Slots). Currently, it doesn't include footer and header pieces (handled by `RootVue` described later), but eventually FlatLayout will handle the entire page.

## RootView -> RootVue

In order to keep using the Backbone router as-is, use a RootVue as a wrapper for your component. Give it a single root Vue component and, if needed, a vuex store module which will be dynamically added upon navigating to the page.

Backbone:

```coffeescript
RootView = require 'views/core/RootView'
module.exports = class MyView extends RootView
  ...
```

Vue:

```coffeescript
RootVue = require 'views/core/RootVue'

MyComponent = Vue.extend
  ...

module.exports = class MyView extends RootVue
  VueComponent: MyComponent
  vuexModule: -> {
    namespaced: true # module will be namespaced to 'page/'
    ...
  }
  ...
```

As shown above, you can include your own vuex module definition, which RootVue will add dynamically as the 'page' module. RootVue will remove that module and all its data when the Router navigates away. This is so that larger pages can take advantage of the vuex store, but also automatically clear any loaded data when no longer needed.

The next step is to set up the Router to handle vue components directly, rather than needing the `RootVue`.

## Internal components

Say you want to take a smaller piece of a Backbone view and make it a Vue component. To do this, create the vue component instance in the Backbone view's `afterRender` method.

```coffeescript
module.exports = class MyView extends CocoView
  afterRender: ->
    @myComponent = new MyComponent({
      el: @$el.find('#small-corner')[0]
      store
    })
    super(arguments...)
```

Ways data can be shared between Backbone and vue components, the Backbone view can:

* grab data through the vuex store object (`require('core/store')`)
* set the vue component's [$data](https://vuejs.org/v2/api/#vm-data)
* listen to vue component changes with [$watch](https://vuejs.org/v2/api/#vm-watch)

## Network Requests

Instead of using `$.ajax` or Backbone model/collection methods, call `api` functions which are wrapped around the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).

```coffeescript
# Backbone Collections/Models
Users = require('collections/Users')
users = new Users()
jqxhr = users.fetch({data: {project:'name'}})
jqxhr.done (rawResponse) -> ...

# Fetch API
api = require('core/api')
promise = api.users.fetch({data: {project:'name'}})
promise.then (rawResponse) -> ...
```

Network errors generated by the API are rejected as objects in the promise. These objects all at least have `message` and `code` properties.

## Page Errors

One of the things the SuperModel does is handle page load errors, re-rendering the page with a generic load error if a necessary resource fails to load. So if you try to go to a classroom page where you don't have access to the page, the SuperModel shows a "Forbidden" error. The PageLayout component can do this as well. However, it's explicit instead of automatic, and it's more easily customizable.

```coffeescript
# SuperModel
users = new Users()
@supermodel.trackRequest(users.fetch()) # shows an error if this resource fails to load
...

# Vue
api.users.fetch({data: {project:'name'}})
.then (users) ->
  ...
.catch (e) ->
  @$store.commit('addPageError', e)
```

This appends the error to a list of errors in the global store, and the PageLayout is set to show the PageErrors component instead of the page content if there are errors. But you can handle these errors however you like for any given page, either by using a different layout component, or doing something else within the `catch`. If network errors are not caught, they show up the same way as they do now: as noty's when in development or logged in as an admin.

## Page Load Progress
There is no generic system for tracking page-load progress to replace the SuperModel. Instead, try using the FontAwesome spinner.

```coffeescript
# Component
MyComponent = Vue.extend
  data: -> {
    loading: true # have a bootstrap progress bar width keyed off this
  }
  created: ->
    p1 = api.thing.fetch()
    p2 = api.otherThing.fetch()
    Promise.all([p1,p2]).then ([res1, res2]) =>
      this.loading = false
```

```jade
// Template
div
  i.fa.fa-spinner.fa-spin.fa-3x(v-if="loading")
  div(v-else) Content...
```

## Bootstrap

Bootstrap components can generally be used the same as they are now. For example, a [modal with a trigger button](http://getbootstrap.com/javascript/#live-demo) will still work if put into Vue. But it's preferable to store all vue component state in the vue component. So with tabs, instead of using [JavaScript to trigger switching between them](http://getbootstrap.com/javascript/#tabs), key the tab [active class](http://getbootstrap.com/components/#nav-tabs) off the component state and set up logic to change the state when a tab is clicked.

```jade
ul.nav.nav-tabs
  li(v-bind:class="{active: tab === 'home' }" click="setTab('home')") Home
  li(v-bind:class="{active: tab === 'profile' }" click="setTab('profile')") Profile
  li(v-bind:class="{active: tab === 'messages' }" click="setTab('messages')") Messages
```

## Handy Tools

Install the [Vue.js Devtools Chrome Extension](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en). Use it to see what components are on the page and the state of the vuex store.

## File Structure

Where to find/put all these new files?

```
/app
  /core
    /api
      fetch-json.coffee: improved Fetch API function
      index.coffee: puts all the other modules in this folder together, makes it possible to require('/core/api')
      <collection>.coffee: all network endpoints for this collection

    /core
      /components: all non-root-level, common components

    /store
      /modules
        me.coffee: Replacement to global "me"
      index.coffee: Where all the global store pieces and modules are put together. Might get broken down later.

    /templates: where all component templates go

    /views: where all root-level components go
      /core
        RootVue.coffee: shims page-level components to the Router
```

## Translations

Instead of passing data through `data-i18n` parameters, call the `i18n.t` function directly through `$t`. It's also available on the vue component instance as `@$t`.

```jade
div(data-i18n="some.key") // with Backbone
div {{ $t("some.key") }} // with Vue
```